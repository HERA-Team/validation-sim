Timer unit: 1e-09 s

Total time: 393.908 s
File: /lustre/aoc/projects/hera/smurray/miniconda3/envs/h4c-sim/lib/python3.10/site-packages/hera_sim/visibilities/cli.py
Function: run_vis_sim at line 88

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    88                                           def run_vis_sim(args):
    89         1    2254500.0    2e+06      0.0      cprint(Panel("hera-sim-vis: Simulating Visibilities"))
    90                                           
    91         1    5534526.0    6e+06      0.0      logger.info("Initializing VisibilitySimulator object... ")
    92         1   18208589.0    2e+07      0.0      simulator = load_simulator_from_yaml(args.simulator_config)
    93         1    4940044.0    5e+06      0.0      logger.info("Finished VisibilitySimulator Init")
    94                                           
    95                                               # Make data_model, simulator, and simulation objects
    96         1    5024412.0    5e+06      0.0      logger.info("Initializing ModelData object... ")
    97         2 7995854769.0    4e+09      2.0      data_model = ModelData.from_config(
    98         1       1382.0   1382.0      0.0          args.obsparam, normalize_beams=args.normalize_beams
    99                                               )
   100         1    6122021.0    6e+06      0.0      logger.info("Finished Setting up ModelData object")
   101         1   43509025.0    4e+07      0.0      print_sim_config(args.obsparam)
   102                                           
   103         1    1044494.0    1e+06      0.0      cprint(f"Using {simulator.__class__.__name__} Simulator")
   104                                           
   105                                               # Print versions
   106         2    5415386.0    3e+06      0.0      cprint(
   107         7       9249.0   1321.3      0.0          f"""
   108                                           [bold]Using the following packages:[/bold]
   109                                           
   110         1       1696.0   1696.0      0.0  \tpyuvdata: {pyuvdata.__version__}
   111         1       5895.0   5895.0      0.0  \tpyuvsim: {pyuvsim.__version__}
   112         1       1119.0   1119.0      0.0  \tpyradiosky: {pyradiosky.__version__}
   113         1       1024.0   1024.0      0.0  \thera_sim: {hera_sim.__version__}
   114         2       1722.0    861.0      0.0  \t{simulator.__class__.__name__}: {simulator.__version__}
   115                                           """
   116                                               )
   117                                           
   118         1    3398822.0    3e+06      0.0      cns.print(Rule("Important Simulation Parameters"))
   119         1    1131578.0    1e+06      0.0      cns.print(f"Nfreqs  : {data_model.uvdata.Nfreqs}")
   120         1    1335315.0    1e+06      0.0      cns.print(f"Ntimes  : {len(data_model.lsts)}")
   121         1    1076466.0    1e+06      0.0      cns.print(f"Npols   : {data_model.uvdata.Npols}")
   122         1    1078619.0    1e+06      0.0      cns.print(f"Nants   : {data_model.uvdata.Nants_data}")
   123         1    1079292.0    1e+06      0.0      cns.print(f"Nsources: {data_model.sky_model.Ncomponents}")
   124         1    1071822.0    1e+06      0.0      cns.print(f"Nbeams  : {data_model.n_beams}")
   125         1     493383.0 493383.0      0.0      cns.print()
   126                                           
   127         1    3126033.0    3e+06      0.0      cns.print(Rule("Large Memory Components"))
   128         2    1233387.0 616693.5      0.0      cns.print(
   129         1      25143.0  25143.0      0.0          f"Visibility Array  : {data_model.uvdata.data_array.nbytes / 1024**2:.2f} MB"
   130                                               )
   131         2      26867.0  13433.5      0.0      beam_array_sizes = [
   132         1        663.0    663.0      0.0          b.data_array.nbytes for b in data_model.beams if hasattr(b, "data_array")
   133                                               ]
   134         1        397.0    397.0      0.0      if beam_array_sizes:
   135         1    1266276.0    1e+06      0.0          cns.print(f"Largest Beam Array: {max(beam_array_sizes) / 1024**2:.2f} MB")
   136         1    1245436.0    1e+06      0.0          cns.print(f"Total Beam Arrays : {sum(beam_array_sizes) / 1024**2:.2f} MB")
   137                                           
   138         1  263728078.0    3e+08      0.1      ram = simulator.estimate_memory(data_model)
   139         1     579383.0 579383.0      0.0      ram_avail = psutil.virtual_memory().available / 1024**3
   140                                           
   141         2    2466722.0    1e+06      0.0      cprint(
   142         3      14938.0   4979.3      0.0          f"[bold {'red' if ram < 1.5 * ram_avail else 'green'}] This simulation will use"
   143         2        745.0    372.5      0.0          f" at least {ram:.2f}GB of RAM (Available: {ram_avail:.2f}GB).[/]"
   144                                               )
   145                                           
   146         1       1938.0   1938.0      0.0      if args.object_name is None:
   147         1      55804.0  55804.0      0.0          data_model.uvdata.object_name = simulator.__class__.__name__
   148                                               else:
   149                                                   data_model.uvdata.object_name = args.object_name
   150                                           
   151         1        819.0    819.0      0.0      if args.dry_run:
   152                                                   cprint("Dry run finished.")
   153                                                   return
   154                                           
   155         1 6702819555.0    7e+09      1.7      simulation = VisibilitySimulation(data_model=data_model, simulator=simulator)
   156                                           
   157                                               # Run simulation
   158         1     891656.0 891656.0      0.0      cprint()
   159         1    3543879.0    4e+06      0.0      cprint(Rule("Running Simulation"))
   160         1    5443192.0    5e+06      0.0      logger.info("About to Run Simulation")
   161         1        4e+11    4e+11     96.1      simulation.simulate()
   162         1    5327299.0    5e+06      0.0      logger.info("Simulation Complete")
   163         1    1548298.0    2e+06      0.0      cprint(Rule())
   164                                           
   165         1       1044.0   1044.0      0.0      if myid != 0:  # pragma: no cover
   166                                                   # Wait for root worker to finish IO before ending all other worker procs
   167                                                   comm.Barrier()
   168                                                   sys.exit(0)
   169                                           
   170         1       6250.0   6250.0      0.0      if args.run_auto_check:
   171                                                   # Check imaginary of xx/yy autos and fix non-real values if the option is
   172                                                   # selected in the arguments
   173                                                   # xxpol = data_model.uvdata.get_data("xx")
   174                                                   # auto_idx = data_model.uvdata.ant_1_array == data_model.uvdata.ant_2_array
   175                                                   # xxpol = xxpol[auto_idx]
   176                                           
   177                                                   # max_xx_autos_to_abs = (np.abs(xxpol.imag) / np.abs(xxpol)).max()
   178                                           
   179                                                   uvd_autos = data_model.uvdata.select(
   180                                                       ant_str="auto",
   181                                                       inplace=False,
   182                                                       run_check=False,
   183                                                       run_check_acceptability=False,
   184                                                       check_extra=False,
   185                                                   )
   186                                                   xx = uvd_autos.get_data("xx")
   187                                                   max_xx_autos_to_abs = (np.abs(xx.imag) / np.abs(xx)).max()
   188                                                   if 0 < max_xx_autos_to_abs < args.max_auto_imag:
   189                                                       logger.warning(
   190                                                           f"[orange]Some autos have very small imaginary components (max ratio "
   191                                                           f"[blue]{max_xx_autos_to_abs:1.2e}[/])"
   192                                                       )
   193                                           
   194                                                       if args.fix_autos:
   195                                                           logger.info("Setting the autos to be purely real... ")
   196                                                           data_model.uvdata._fix_autos()
   197                                                           logger.info("Done fixing autos.")
   198                                           
   199                                                   elif max_xx_autos_to_abs >= args.max_auto_imag:
   200                                                       raise ValueError(
   201                                                           f"Some autos have large fractional imaginary components "
   202                                                           f"(>{args.max_auto_imag:1.2e}). Largest value = "
   203                                                           f"{np.abs(xx.imag).max():1.2e}, largest fraction="
   204                                                           f"{max_xx_autos_to_abs:1.2e}."
   205                                                       )
   206                                           
   207         1       3935.0   3935.0      0.0      if args.compress:
   208         1    5285845.0    5e+06      0.0          logger.info("Compressing data by redundancy... ")
   209                                                   # Here, we don't call the convenience function directly, because we want to
   210                                                   # be able to short-circuit the process by reading in a file.
   211         1     418739.0 418739.0      0.0          if not Path(args.compress).exists():
   212         3   11868886.0    4e+06      0.0              red_gps = data_model.uvdata.get_redundancies(
   213         1        447.0    447.0      0.0                  tol=1.0, include_conjugates=True
   214         1        606.0    606.0      0.0              )[0]
   215         1    1900900.0    2e+06      0.0              bl_ants = [data_model.uvdata.baseline_to_antnums(gp[0]) for gp in red_gps]
   216         3   39208700.0    1e+07      0.0              blt_inds = data_model.uvdata._select_preprocess(
   217         1        365.0    365.0      0.0                  antenna_nums=None,
   218         1        218.0    218.0      0.0                  antenna_names=None,
   219         1        300.0    300.0      0.0                  ant_str=None,
   220         1        244.0    244.0      0.0                  bls=bl_ants,
   221         1        226.0    226.0      0.0                  frequencies=None,
   222         1        253.0    253.0      0.0                  freq_chans=None,
   223         1        269.0    269.0      0.0                  times=None,
   224         1        206.0    206.0      0.0                  time_range=None,
   225         1        220.0    220.0      0.0                  lsts=None,
   226         1        243.0    243.0      0.0                  lst_range=None,
   227         1        261.0    261.0      0.0                  polarizations=None,
   228         1        215.0    215.0      0.0                  blt_inds=None,
   229         1        275.0    275.0      0.0                  phase_center_ids=None,
   230         1        220.0    220.0      0.0                  catalog_names=None,
   231         1        880.0    880.0      0.0              )[0]
   232                                           
   233         1    3825043.0    4e+06      0.0              np.save(args.compress, blt_inds)
   234                                                   else:
   235                                                       blt_inds = np.load(args.compress)
   236                                           
   237         2    6169428.0    3e+06      0.0          data_model.uvdata._select_by_index(
   238         1        637.0    637.0      0.0              blt_inds, None, None, "Compressed by redundancy", keep_all_metadata=True
   239                                                   )
   240                                           
   241         1    5541895.0    6e+06      0.0          logger.info("Done with compression.")
   242                                           
   243                                               # Read obsparams to get filing config
   244         2     738239.0 369119.5      0.0      with open(args.obsparam) as file:
   245         1   15600607.0    2e+07      0.0          obsparam_dict = yaml.safe_load(file)
   246         1       5570.0   5570.0      0.0      cfg_filing = obsparam_dict["filing"]
   247         1     102268.0 102268.0      0.0      base_path = Path(cfg_filing["outdir"])
   248         1     843731.0 843731.0      0.0      base_path.mkdir(parents=True, exist_ok=True)
   249         1      71813.0  71813.0      0.0      outfile = base_path / f"{cfg_filing['outfile_name']}.{cfg_filing['output_format']}"
   250         1       2880.0   2880.0      0.0      clobber = cfg_filing.get("clobber", False)
   251                                           
   252                                               # Write output
   253         1    5652716.0    6e+06      0.0      logger.info("Writing output... ")
   254         2   44524438.0    2e+07      0.0      data_model.uvdata.write_uvh5(
   255         1      30500.0  30500.0      0.0          outfile.as_posix(),
   256         1        332.0    332.0      0.0          clobber=clobber,
   257         1        443.0    443.0      0.0          run_check=False,
   258         1        259.0    259.0      0.0          run_check_acceptability=False,
   259                                               )
   260         1    5295109.0    5e+06      0.0      logger.info("Done Writing.")
   261                                           
   262                                               # Sync with other workers and finalise
   263         1        864.0    864.0      0.0      if HAVE_MPI:
   264                                                   comm.Barrier()
   265                                           
   266         1    1388643.0    1e+06      0.0      cprint("[green][bold]Complete![/][/]")

Total time: 377.524 s
File: /lustre/aoc/projects/hera/smurray/miniconda3/envs/h4c-sim/lib/python3.10/site-packages/matvis/cpu.py
Function: simulate at line 199

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   199                                           @profile
   200                                           def simulate(
   201                                               *,
   202                                               antpos: np.ndarray,
   203                                               freq: float,
   204                                               eq2tops: np.ndarray,
   205                                               crd_eq: np.ndarray,
   206                                               I_sky: np.ndarray,
   207                                               beam_list: Sequence[UVBeam | Callable] | None,
   208                                               precision: int = 1,
   209                                               polarized: bool = False,
   210                                               beam_idx: np.ndarray | None = None,
   211                                               beam_spline_opts: dict | None = None,
   212                                               max_progress_reports: int = 100,
   213                                           ):
   214                                               """
   215                                               Calculate visibility from an input intensity map and beam model.
   216                                           
   217                                               Parameters
   218                                               ----------
   219                                               antpos : array_like
   220                                                   Antenna position array. Shape=(NANT, 3).
   221                                               freq : float
   222                                                   Frequency to evaluate the visibilities at [GHz].
   223                                               eq2tops : array_like
   224                                                   Set of 3x3 transformation matrices to rotate the RA and Dec
   225                                                   cosines in an ECI coordinate system (see `crd_eq`) to
   226                                                   topocentric ENU (East-North-Up) unit vectors at each
   227                                                   time/LST/hour angle in the dataset.
   228                                                   Shape=(NTIMES, 3, 3).
   229                                               crd_eq : array_like
   230                                                   Cartesian unit vectors of sources in an ECI (Earth Centered
   231                                                   Inertial) system, which has the Earth's center of mass at
   232                                                   the origin, and is fixed with respect to the distant stars.
   233                                                   The components of the ECI vector for each source are:
   234                                                   (cos(RA) cos(Dec), sin(RA) cos(Dec), sin(Dec)).
   235                                                   Shape=(3, NSRCS).
   236                                               I_sky : array_like
   237                                                   Intensity distribution of sources/pixels on the sky, assuming intensity
   238                                                   (Stokes I) only. The Stokes I intensity will be split equally between
   239                                                   the two linear polarization channels, resulting in a factor of 0.5 from
   240                                                   the value inputted here. This is done even if only one polarization
   241                                                   channel is simulated.
   242                                                   Shape=(NSRCS,).
   243                                               beam_list : list of UVBeam, optional
   244                                                   If specified, evaluate primary beam values directly using UVBeam
   245                                                   objects instead of using pixelized beam maps. Only one of ``bm_cube`` and
   246                                                   ``beam_list`` should be provided.Note that if `polarized` is True,
   247                                                   these beams must be efield beams, and conversely if `polarized` is False they
   248                                                   must be power beams with a single polarization (either XX or YY).
   249                                               precision : int, optional
   250                                                   Which precision level to use for floats and complex numbers.
   251                                                   Allowed values:
   252                                                   - 1: float32, complex64
   253                                                   - 2: float64, complex128
   254                                               polarized : bool, optional
   255                                                   Whether to simulate a full polarized response in terms of nn, ne, en,
   256                                                   ee visibilities. See Eq. 6 of Kohn+ (arXiv:1802.04151) for notation.
   257                                                   Default: False.
   258                                               beam_idx
   259                                                   Optional length-NANT array specifying a beam index for each antenna.
   260                                                   By default, either a single beam is assumed to apply to all antennas or
   261                                                   each antenna gets its own beam.
   262                                               beam_spline_opts : dict, optional
   263                                                   Dictionary of options to pass to the beam interpolation function.
   264                                               max_progress_reports : int, optional
   265                                                   Maximum number of progress reports to print to the screen (if logging level
   266                                                   allows). Default is 100.
   267                                           
   268                                               Returns
   269                                               -------
   270                                               vis : array_like
   271                                                   Simulated visibilities. If `polarized = True`, the output will have
   272                                                   shape (NTIMES, NFEED, NFEED, NANTS, NANTS), otherwise it will have
   273                                                   shape (NTIMES, NANTS, NANTS).
   274                                               """
   275         1       7970.0   7970.0      0.0      if not tm.is_tracing() and logger.isEnabledFor(logging.INFO):
   276                                                   tm.start()
   277                                           
   278         1   16130975.0    2e+07      0.0      highest_peak = _memtrace(0)
   279                                           
   280         2      20598.0  10299.0      0.0      nax, nfeed, nant, ntimes = _validate_inputs(
   281         1        413.0    413.0      0.0          precision, polarized, antpos, eq2tops, crd_eq, I_sky
   282                                               )
   283                                           
   284         1        540.0    540.0      0.0      if precision == 1:
   285                                                   real_dtype = np.float32
   286                                                   complex_dtype = np.complex64
   287                                               else:
   288         1       1238.0   1238.0      0.0          real_dtype = np.float64
   289         1        802.0    802.0      0.0          complex_dtype = np.complex128
   290                                           
   291         2  165224915.0    8e+07      0.0      beam_list, nbeam, beam_idx = _wrangle_beams(
   292         1        332.0    332.0      0.0          beam_idx, beam_list, polarized, nant, freq
   293                                               )
   294                                           
   295                                               # Intensity distribution (sqrt) and antenna positions. Does not support
   296                                               # negative sky. Factor of 0.5 accounts for splitting Stokes I between
   297                                               # polarization channels
   298         1    3935358.0    4e+06      0.0      Isqrt = np.sqrt(0.5 * I_sky).astype(real_dtype)
   299         1       6512.0   6512.0      0.0      antpos = antpos.astype(real_dtype)
   300                                           
   301         1       8023.0   8023.0      0.0      ang_freq = real_dtype(2.0 * np.pi * freq)
   302                                           
   303                                               # Zero arrays: beam pattern, visibilities, delays, complex voltages
   304         1      92563.0  92563.0      0.0      vis = np.full((ntimes, nfeed * nant, nfeed * nant), 0.0, dtype=complex_dtype)
   305         1    5726555.0    6e+06      0.0      logger.info(f"Visibility Array takes {vis.nbytes/1024**2:.1f} MB")
   306                                           
   307         1    2566430.0    3e+06      0.0      crd_eq = crd_eq.astype(real_dtype)
   308                                           
   309                                               # Have up to 100 reports as it iterates through time.
   310         1       2314.0   2314.0      0.0      report_chunk = ntimes // max_progress_reports + 1
   311         1     441527.0 441527.0      0.0      pr = psutil.Process()
   312         1       2905.0   2905.0      0.0      tstart = time.time()
   313         1     104371.0 104371.0      0.0      mlast = pr.memory_info().rss
   314         1        349.0    349.0      0.0      plast = tstart
   315                                           
   316         1   16021527.0    2e+07      0.0      highest_peak = _memtrace(highest_peak)
   317                                           
   318                                               # Loop over time samples
   319       181    1059432.0   5853.2      0.0      for t, eq2top in enumerate(eq2tops.astype(real_dtype)):
   320                                                   # Dot product converts ECI cosines (i.e. from RA and Dec) into ENU
   321                                                   # (topocentric) cosines, with (tx, ty, tz) = (e, n, u) components
   322                                                   # relative to the center of the array
   323       180 1525147032.0    8e+06      0.4          tx, ty, tz = crd_top = np.dot(eq2top, crd_eq)
   324       180   95861463.0 532563.7      0.0          above_horizon = tz > 0
   325       180  172196410.0 956646.7      0.0          tx = tx[above_horizon]
   326       180  180928848.0    1e+06      0.0          ty = ty[above_horizon]
   327       180     947222.0   5262.3      0.0          nsrcs_up = len(tx)
   328       180  176807699.0 982265.0      0.0          isqrt = Isqrt[above_horizon]
   329                                           
   330       180  543116009.0    3e+06      0.1          A_s = np.full((nax, nfeed, nbeam, nsrcs_up), 0.0, dtype=complex_dtype)
   331                                           
   332       360        2e+11    7e+08     65.1          _evaluate_beam_cpu(
   333       180      71988.0    399.9      0.0              A_s,
   334       180      87940.0    488.6      0.0              beam_list,
   335       180      86394.0    480.0      0.0              tx,
   336       180     128460.0    713.7      0.0              ty,
   337       180      62431.0    346.8      0.0              polarized,
   338       180      89018.0    494.5      0.0              freq,
   339       180     234393.0   1302.2      0.0              check=t == 0,
   340       180      80937.0    449.6      0.0              spline_opts=beam_spline_opts,
   341                                                   )
   342       180    2157742.0  11987.5      0.0          A_s = A_s.transpose((1, 2, 0, 3))  # Now (Nfeed, Nbeam, Nax, Nsrc)
   343                                           
   344       180    2240693.0  12448.3      0.0          _log_array("beam", A_s)
   345                                           
   346                                                   # Calculate delays, where tau = (b * s) / c
   347       180 3187372749.0    2e+07      0.8          tau = np.dot(antpos / c.value, crd_top[:, above_horizon])
   348       180    2464897.0  13693.9      0.0          _log_array("tau", tau)
   349                                           
   350       360        1e+11    3e+08     26.1          v = _get_antenna_vis(
   351       180     179544.0    997.5      0.0              A_s, ang_freq, tau, isqrt, beam_idx, nfeed, nant, nax, nsrcs_up
   352                                                   )
   353       180    2493990.0  13855.5      0.0          _log_array("vant", v)
   354                                           
   355                                                   # Compute visibilities using product of complex voltages (upper triangle).
   356       180        2e+10    1e+08      6.4          vis[t] = v.conj().dot(v.T)
   357       180    2964375.0  16468.8      0.0          _log_array("vis", vis[t])
   358                                           
   359       180     531807.0   2954.5      0.0          if not (t % report_chunk or t == ntimes - 1):
   360        90 1281866865.0    1e+07      0.3              plast, mlast = _log_progress(tstart, plast, t + 1, ntimes, pr, mlast)
   361        90 1436399305.0    2e+07      0.4              highest_peak = _memtrace(highest_peak)
   362                                           
   363         1       6324.0   6324.0      0.0      vis.shape = (ntimes, nfeed, nant, nfeed, nant)
   364                                           
   365                                               # Return visibilities with or without multiple polarization channels
   366         1       8450.0   8450.0      0.0      return vis.transpose((0, 1, 3, 2, 4)) if polarized else vis[:, 0, :, 0, :]

