Timer unit: 1e-09 s

Total time: 281.045 s
File: /jet/home/sgm/miniconda3/envs/h6c/lib/python3.10/site-packages/hera_sim/visibilities/cli.py
Function: run_vis_sim at line 88

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    88                                           def run_vis_sim(args):
    89         1    1776953.0    2e+06      0.0      cprint(Panel("hera-sim-vis: Simulating Visibilities"))
    90                                           
    91         1    4307566.0    4e+06      0.0      logger.info("Initializing VisibilitySimulator object... ")
    92         1    3463907.0    3e+06      0.0      simulator = load_simulator_from_yaml(args.simulator_config)
    93         1    3802137.0    4e+06      0.0      logger.info("Finished VisibilitySimulator Init")
    94                                           
    95                                               # Make data_model, simulator, and simulation objects
    96         1    3741325.0    4e+06      0.0      logger.info("Initializing ModelData object... ")
    97         2        1e+11    7e+10     53.0      data_model = ModelData.from_config(
    98         1       1647.0   1647.0      0.0          args.obsparam, normalize_beams=args.normalize_beams
    99                                               )
   100         1    4178957.0    4e+06      0.0      logger.info("Finished Setting up ModelData object")
   101         1   31832014.0    3e+07      0.0      print_sim_config(args.obsparam)
   102                                           
   103         1     787690.0 787690.0      0.0      cprint(f"Using {simulator.__class__.__name__} Simulator")
   104                                           
   105                                               # Print versions
   106         2    4131173.0    2e+06      0.0      cprint(
   107         7       5903.0    843.3      0.0          f"""
   108                                           [bold]Using the following packages:[/bold]
   109                                           
   110         1       3761.0   3761.0      0.0  \tpyuvdata: {pyuvdata.__version__}
   111         1       3868.0   3868.0      0.0  \tpyuvsim: {pyuvsim.__version__}
   112         1       1136.0   1136.0      0.0  \tpyradiosky: {pyradiosky.__version__}
   113         1       3065.0   3065.0      0.0  \thera_sim: {hera_sim.__version__}
   114         2       2626.0   1313.0      0.0  \t{simulator.__class__.__name__}: {simulator.__version__}
   115                                           """
   116                                               )
   117                                           
   118         1    2642248.0    3e+06      0.0      cns.print(Rule("Important Simulation Parameters"))
   119         1     852053.0 852053.0      0.0      cns.print(f"Nfreqs  : {data_model.uvdata.Nfreqs}")
   120         1  466966469.0    5e+08      0.2      cns.print(f"Ntimes  : {len(data_model.lsts)}")
   121         1     866104.0 866104.0      0.0      cns.print(f"Npols   : {data_model.uvdata.Npols}")
   122         1     821767.0 821767.0      0.0      cns.print(f"Nants   : {data_model.uvdata.Nants_data}")
   123         1     798755.0 798755.0      0.0      cns.print(f"Nsources: {data_model.sky_model.Ncomponents}")
   124         1     821286.0 821286.0      0.0      cns.print(f"Nbeams  : {data_model.n_beams}")
   125         1     379683.0 379683.0      0.0      cns.print()
   126                                           
   127         1    2447283.0    2e+06      0.0      cns.print(Rule("Large Memory Components"))
   128         2     944277.0 472138.5      0.0      cns.print(
   129         1      24073.0  24073.0      0.0          f"Visibility Array  : {data_model.uvdata.data_array.nbytes / 1024**2:.2f} MB"
   130                                               )
   131         2      18739.0   9369.5      0.0      beam_array_sizes = [
   132         1        709.0    709.0      0.0          b.data_array.nbytes for b in data_model.beams if hasattr(b, "data_array")
   133                                               ]
   134         1        277.0    277.0      0.0      if beam_array_sizes:
   135         1     911965.0 911965.0      0.0          cns.print(f"Largest Beam Array: {max(beam_array_sizes) / 1024**2:.2f} MB")
   136         1     908508.0 908508.0      0.0          cns.print(f"Total Beam Arrays : {sum(beam_array_sizes) / 1024**2:.2f} MB")
   137                                           
   138         1    1408829.0    1e+06      0.0      ram = simulator.estimate_memory(data_model)
   139         1     351284.0 351284.0      0.0      ram_avail = psutil.virtual_memory().available / 1024**3
   140                                           
   141         2    1861313.0 930656.5      0.0      cprint(
   142         3       8495.0   2831.7      0.0          f"[bold {'red' if ram < 1.5*ram_avail else 'green'}] This simulation will use "
   143         2        457.0    228.5      0.0          f"at least {ram:.2f}GB of RAM (Available: {ram_avail:.2f}GB).[/]"
   144                                               )
   145                                           
   146         1       2301.0   2301.0      0.0      if args.object_name is None:
   147         1      46971.0  46971.0      0.0          data_model.uvdata.object_name = simulator.__class__.__name__
   148                                               else:
   149                                                   data_model.uvdata.object_name = args.object_name
   150                                           
   151         1        685.0    685.0      0.0      if args.dry_run:
   152                                                   cprint("Dry run finished.")
   153                                                   return
   154                                           
   155         1 2278487802.0    2e+09      0.8      simulation = VisibilitySimulation(data_model=data_model, simulator=simulator)
   156                                           
   157                                               # Run simulation
   158         1     433466.0 433466.0      0.0      cprint()
   159         1    2482301.0    2e+06      0.0      cprint(Rule("Running Simulation"))
   160         1    3614447.0    4e+06      0.0      logger.info("About to Run Simulation")
   161         1        8e+10    8e+10     27.0      simulation.simulate()
   162         1    5275363.0    5e+06      0.0      logger.info("Simulation Complete")
   163         1    1234948.0    1e+06      0.0      cprint(Rule())
   164                                           
   165         1        627.0    627.0      0.0      if myid != 0:  # pragma: no cover
   166                                                   # Wait for root worker to finish IO before ending all other worker procs
   167                                                   comm.Barrier()
   168                                                   sys.exit(0)
   169                                           
   170         1        308.0    308.0      0.0      if myid == 0:
   171                                                   # Check imaginary of xx/yy autos and fix non-real values if the option is
   172                                                   # selected in the arguments
   173                                                   # xxpol = data_model.uvdata.get_data("xx")
   174                                                   # auto_idx = data_model.uvdata.ant_1_array == data_model.uvdata.ant_2_array
   175                                                   # xxpol = xxpol[auto_idx]
   176                                           
   177                                                   # max_xx_autos_to_abs = (np.abs(xxpol.imag) / np.abs(xxpol)).max()
   178                                           
   179         2        5e+10    3e+10     18.0          uvd_autos = data_model.uvdata.select(
   180         1        268.0    268.0      0.0              ant_str="auto",
   181         1        205.0    205.0      0.0              inplace=False,
   182         1        202.0    202.0      0.0              run_check=False,
   183         1        219.0    219.0      0.0              run_check_acceptability=False,
   184         1        164.0    164.0      0.0              check_extra=False,
   185                                                   )
   186         1   86386737.0    9e+07      0.0          xx = uvd_autos.get_data("xx")
   187         1    3971215.0    4e+06      0.0          max_xx_autos_to_abs = (np.abs(xx.imag) / np.abs(xx)).max()
   188         1      33365.0  33365.0      0.0          if 0 < max_xx_autos_to_abs < args.max_auto_imag:
   189         2    6569312.0    3e+06      0.0              logger.warning(
   190         2      57302.0  28651.0      0.0                  f"[orange]Some autos have very small imaginary components (max ratio "
   191         1       1297.0   1297.0      0.0                  f"[blue]{max_xx_autos_to_abs:1.2e}[/])"
   192                                                       )
   193                                           
   194         1       1376.0   1376.0      0.0              if args.fix_autos:
   195         1    4183905.0    4e+06      0.0                  logger.info("Setting the autos to be purely real... ")
   196         1  260494392.0    3e+08      0.1                  data_model.uvdata._fix_autos()
   197         1    4186066.0    4e+06      0.0                  logger.info("Done fixing autos.")
   198                                           
   199                                                   elif max_xx_autos_to_abs >= args.max_auto_imag:
   200                                                       raise ValueError(
   201                                                           f"Some autos have large fractional imaginary components "
   202                                                           f"(>{args.max_auto_imag:1.2e}). Largest value = "
   203                                                           f"{np.abs(xx.imag).max():1.2e}, largest fraction="
   204                                                           f"{max_xx_autos_to_abs:1.2e}."
   205                                                       )
   206                                           
   207         1      10521.0  10521.0      0.0          if args.compress:
   208         1    3870331.0    4e+06      0.0              logger.info("Compressing data by redundancy... ")
   209                                                       # Here, we don't call the convenience function directly, because we want to
   210                                                       # be able to short-circuit the process by reading in a file.
   211         1     792816.0 792816.0      0.0              if not Path(args.compress).exists():
   212                                                           red_gps = data_model.uvdata.get_redundancies(
   213                                                               tol=1.0, include_conjugates=True
   214                                                           )[0]
   215                                                           bl_ants = [
   216                                                               data_model.uvdata.baseline_to_antnums(gp[0]) for gp in red_gps
   217                                                           ]
   218                                                           blt_inds = data_model.uvdata._select_preprocess(
   219                                                               antenna_nums=None,
   220                                                               antenna_names=None,
   221                                                               ant_str=None,
   222                                                               bls=bl_ants,
   223                                                               frequencies=None,
   224                                                               freq_chans=None,
   225                                                               times=None,
   226                                                               time_range=None,
   227                                                               lsts=None,
   228                                                               lst_range=None,
   229                                                               polarizations=None,
   230                                                               blt_inds=None,
   231                                                               phase_center_ids=None,
   232                                                               catalog_names=None,
   233                                                           )[0]
   234                                           
   235                                                           np.save(args.compress, blt_inds)
   236                                                       else:
   237         1   73674507.0    7e+07      0.0                  blt_inds = np.load(args.compress)
   238                                           
   239         2 1591609588.0    8e+08      0.6              data_model.uvdata._select_by_index(
   240         1       6440.0   6440.0      0.0                  blt_inds, None, None, "Compressed by redundancy", keep_all_metadata=True
   241                                                       )
   242                                           
   243         1    4135252.0    4e+06      0.0              logger.info("Done with compression.")
   244                                           
   245                                                   # Read obsparams to get filing config
   246         2     662080.0 331040.0      0.0          with open(args.obsparam) as file:
   247         1   11555879.0    1e+07      0.0              obsparam_dict = yaml.safe_load(file)
   248         1       3387.0   3387.0      0.0          cfg_filing = obsparam_dict["filing"]
   249         1      66185.0  66185.0      0.0          base_path = Path(cfg_filing["outdir"])
   250         1     843855.0 843855.0      0.0          base_path.mkdir(parents=True, exist_ok=True)
   251         1        424.0    424.0      0.0          outfile = (
   252         1      39153.0  39153.0      0.0              base_path / f"{cfg_filing['outfile_name']}.{cfg_filing['output_format']}"
   253                                                   )
   254         1       3751.0   3751.0      0.0          clobber = cfg_filing.get("clobber", False)
   255                                           
   256                                                   # Write output
   257         1    4083287.0    4e+06      0.0          logger.info("Writing output... ")
   258         2  658739056.0    3e+08      0.2          data_model.uvdata.write_uvh5(
   259         1      19658.0  19658.0      0.0              outfile.as_posix(),
   260         1        249.0    249.0      0.0              clobber=clobber,
   261         1        236.0    236.0      0.0              run_check=False,
   262         1        188.0    188.0      0.0              run_check_acceptability=False,
   263                                                   )
   264         1    3962641.0    4e+06      0.0          logger.info("Done Writing.")
   265                                           
   266                                               # Sync with other workers and finalise
   267         1       5255.0   5255.0      0.0      if HAVE_MPI:
   268                                                   comm.Barrier()
   269                                           
   270         1    1101301.0    1e+06      0.0      cprint("[green][bold]Complete![/][/]")

Total time: 13.6797 s
File: /jet/home/sgm/miniconda3/envs/h6c/lib/python3.10/site-packages/matvis/gpu.py
Function: simulate at line 99

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    99                                           @profile
   100                                           def simulate(
   101                                               *,
   102                                               antpos: np.ndarray,
   103                                               freq: float,
   104                                               eq2tops: np.ndarray,
   105                                               crd_eq: np.ndarray,
   106                                               I_sky: np.ndarray,
   107                                               beam_list: Sequence[UVBeam | Callable] | None,
   108                                               polarized: bool = False,
   109                                               beam_idx: np.ndarray | None = None,
   110                                               nthreads: int = 1024,
   111                                               max_memory: int = 2**29,
   112                                               min_chunks: int = 1,
   113                                               precision: int = 1,
   114                                               beam_spline_opts: dict | None = None,
   115                                           ) -> np.ndarray:
   116                                               """GPU implementation of the visibility simulator."""
   117         1       4563.0   4563.0      0.0      if not HAVE_CUDA:
   118                                                   raise ImportError("You need to install the [gpu] extra to use this function!")
   119                                           
   120         1     470485.0 470485.0      0.0      pr = psutil.Process()
   121         2      19022.0   9511.0      0.0      nax, nfeed, nant, ntimes = _validate_inputs(
   122         1        394.0    394.0      0.0          precision, polarized, antpos, eq2tops, crd_eq, I_sky
   123                                               )
   124                                           
   125         1        385.0    385.0      0.0      if beam_spline_opts:
   126         2     166756.0  83378.0      0.0          warnings.warn(
   127         1        337.0    337.0      0.0              "You have passed beam_spline_opts, but these are not used in GPU.",
   128         1        186.0    186.0      0.0              stacklevel=1,
   129                                                   )
   130                                           
   131         1       1369.0   1369.0      0.0      nsrc = len(I_sky)
   132                                           
   133         1        614.0    614.0      0.0      if precision == 1:
   134                                                   real_dtype, complex_dtype = np.float32, np.complex64
   135                                                   cublas_real_mm = cublasSgemm
   136                                                   cublas_complex_mm = cublasCgemm
   137                                               else:
   138         1       1492.0   1492.0      0.0          real_dtype, complex_dtype = np.float64, np.complex128
   139         1       2549.0   2549.0      0.0          cublas_real_mm = cublasDgemm
   140         1        492.0    492.0      0.0          cublas_complex_mm = cublasZgemm
   141                                           
   142         1       2323.0   2323.0      0.0      DTYPE, CDTYPE = TYPE_MAP[real_dtype], TYPE_MAP[complex_dtype]
   143                                           
   144                                               # apply scalars so 1j*tau*freq is the correct exponent
   145         1       3793.0   3793.0      0.0      ang_freq = 2 * freq * np.pi
   146                                           
   147                                               # ensure data types
   148         1      12356.0  12356.0      0.0      antpos = antpos.astype(real_dtype)
   149         1      15363.0  15363.0      0.0      eq2tops = eq2tops.astype(real_dtype)
   150         1      20111.0  20111.0      0.0      crd_eq = crd_eq.astype(real_dtype)
   151         1      27853.0  27853.0      0.0      Isqrt = np.sqrt(0.5 * I_sky).astype(real_dtype)
   152                                           
   153         2  154904998.0    8e+07      1.1      beam_list, nbeam, beam_idx = _wrangle_beams(
   154         1        362.0    362.0      0.0          beam_idx=beam_idx,
   155         1        329.0    329.0      0.0          beam_list=beam_list,
   156         1        182.0    182.0      0.0          polarized=polarized,
   157         1        437.0    437.0      0.0          nant=nant,
   158         1        180.0    180.0      0.0          freq=freq,
   159                                               )
   160                                           
   161         2      20063.0  10031.5      0.0      total_beam_pix = sum(
   162                                                   beam.data_array.shape[-2] * beam.data_array.shape[-1]
   163         1        194.0    194.0      0.0          for beam in beam_list
   164                                                   if hasattr(beam, "data_array")
   165                                               )
   166                                           
   167         2       1770.0    885.0      0.0      nchunks = min(
   168         2       1918.0    959.0      0.0          max(
   169         1        815.0    815.0      0.0              min_chunks,
   170         2    5570152.0    3e+06      0.0              _get_required_chunks(
   171         1        368.0    368.0      0.0                  nax, nfeed, nant, nsrc, nbeam, total_beam_pix, precision
   172                                                       ),
   173                                                   ),
   174         1        324.0    324.0      0.0          nsrc,
   175                                               )
   176                                           
   177         1        854.0    854.0      0.0      npixc = nsrc // nchunks
   178                                           
   179         1       1305.0   1305.0      0.0      use_uvbeam = isinstance(beam_list[0], UVBeam)
   180         1       4985.0   4985.0      0.0      if use_uvbeam and not all(isinstance(b, UVBeam) for b in beam_list):
   181                                                   raise ValueError(
   182                                                       "gpu.simulate only support beam_lists with either all UVBeam or all AnalyticBeam objects."
   183                                                   )
   184                                           
   185         1       7300.0   7300.0      0.0      cuda_params = {
   186         1        225.0    225.0      0.0          "NANT": nant,
   187         1        214.0    214.0      0.0          "NAX": nax,
   188         1        185.0    185.0      0.0          "NFEED": nfeed,
   189         1        263.0    263.0      0.0          "NBEAM": nbeam,
   190         1        339.0    339.0      0.0          "DTYPE": DTYPE,
   191         1        254.0    254.0      0.0          "CDTYPE": CDTYPE,
   192         1        329.0    329.0      0.0          "f": "f" if precision == 1 else "",
   193                                               }
   194                                           
   195         1        225.0    225.0      0.0      if use_uvbeam:
   196                                                   # We need to make sure that each beam "raw" data is on the same grid.
   197                                                   # There is no advantage to using any other resolution but the native raw
   198                                                   # resolution, which is what is returned by default. This may not be the case
   199                                                   # if we were to use higher-order splines in the initial interpolation from
   200                                                   # UVBeam. Eg. if "cubic" interpolation was shown to be better than linear,
   201                                                   # we might want to do cubic interpolation with pyuvbeam onto a much higher-res
   202                                                   # grid, then use linear interpolation on the GPU with that high-res grid.
   203                                                   # We can explore this later...
   204         1    2411134.0    2e+06      0.0          d0, daz, dza = uvbeam_to_azza_grid(beam_list[0])
   205         1       5347.0   5347.0      0.0          naz = 2 * np.pi / daz + 1
   206         1     169980.0 169980.0      0.0          assert np.isclose(int(naz), naz)
   207                                           
   208         1       1544.0   1544.0      0.0          raw_beam_data = [d0]
   209         1       1046.0   1046.0      0.0          if len(beam_list) > 1:
   210                                                       raw_beam_data.extend(
   211                                                           uvbeam_to_azza_grid(b, naz=int(naz), dza=dza)[0] for b in beam_list[1:]
   212                                                       )
   213                                               else:
   214                                                   daz, dza = None, None
   215                                           
   216                                               # Setup the GPU code and arrays
   217         1     300502.0 300502.0      0.0      meas_eq_code = MeasEqTemplate.render(**cuda_params)
   218                                           
   219         1        316.0    316.0      0.0      if use_uvbeam:
   220         2     224953.0 112476.5      0.0          beam_interp_code = BeamInterpTemplate.render(
   221         3       3201.0   1067.0      0.0              **{
   222         1        230.0    230.0      0.0                  **cuda_params,
   223         1       2494.0   2494.0      0.0                  **{
   224         1        230.0    230.0      0.0                      "NBEAM": nbeam,
   225         1       2500.0   2500.0      0.0                      "BEAM_N_AZ": raw_beam_data[0].shape[-1],
   226         1       1505.0   1505.0      0.0                      "BEAM_N_ZA": raw_beam_data[0].shape[-2],
   227         1        183.0    183.0      0.0                      "DAZ": daz,
   228         1        209.0    209.0      0.0                      "DZA": dza,
   229                                                           },
   230                                                       }
   231                                                   )
   232         1  290184693.0    3e+08      2.1          beam_interp_module = compiler.SourceModule(beam_interp_code)
   233         1     226513.0 226513.0      0.0          beam_interp = beam_interp_module.get_function("InterpolateBeamAltAz")
   234                                               else:
   235                                                   beam_interp = None
   236                                           
   237         1  202890347.0    2e+08      1.5      meas_eq_module = compiler.SourceModule(meas_eq_code)
   238         1      62119.0  62119.0      0.0      meas_eq = meas_eq_module.get_function("MeasEq")
   239                                               # vis_inner_product = meas_eq_module.get_function("VisInnerProduct")
   240                                           
   241         2    7354217.0    4e+06      0.1      logger.info(
   242         5      11825.0   2365.0      0.0          f"""
   243                                                   Measurement Equation Kernel Properties:
   244         1      37262.0  37262.0      0.0              SHARED: {meas_eq.shared_size_bytes}
   245         1       9937.0   9937.0      0.0              LOCAL: {meas_eq.local_size_bytes}
   246         1       8658.0   8658.0      0.0              REGISTERS: {meas_eq.num_regs}
   247         1       9718.0   9718.0      0.0              MAX_THREADS_PER_BLOCK: {meas_eq.max_threads_per_block}
   248                                                   """
   249                                               )
   250                                           
   251                                               # bm_texref = gpu_module.get_texref("bm_tex")
   252         1    2511079.0    3e+06      0.0      h = cublasCreate()  # handle for managing cublas
   253                                           
   254                                               # define GPU buffers and transfer initial values
   255                                               # never changes, transpose happens in copy so cuda bm_tex is (BEAM_PX,BEAM_PX,NANT)
   256                                               # bm_texref.set_array(numpy3d_to_array(beams))
   257         1     454921.0 454921.0      0.0      antpos_gpu = gpuarray.to_gpu(antpos)  # never changes, set to -2*pi*antpos/c
   258         1     187960.0 187960.0      0.0      beam_idx = gpuarray.to_gpu(beam_idx.astype(np.uint))
   259         1      69064.0  69064.0      0.0      Isqrt_gpu = gpuarray.empty(shape=(npixc,), dtype=real_dtype)
   260                                           
   261                                               # Send the regular-grid beam data to the GPU. This has dimensions (Nbeam, Nax, Nfeed, Nza, Nza)
   262                                               # Note that Nbeam is not in general equal to Nant (we can have multiple antennas with
   263                                               # the same beam).
   264         1        310.0    310.0      0.0      if use_uvbeam:
   265         2    1619447.0 809723.5      0.0          beam_data_gpu = gpuarray.to_gpu(
   266         1     936907.0 936907.0      0.0              np.array(raw_beam_data, dtype=complex_dtype if polarized else real_dtype),
   267                                                   )
   268                                               else:
   269                                                   beam_data_gpu = None
   270                                           
   271                                               # will be set on GPU by bm_interp
   272         1     107086.0 107086.0      0.0      crd_eq_gpu = gpuarray.empty(shape=(3, npixc), dtype=real_dtype)
   273                                               # sent from CPU each time
   274         1      54397.0  54397.0      0.0      eq2top_gpu = gpuarray.empty(shape=(3, 3), dtype=real_dtype)
   275                                               # will be set on GPU
   276         1      30141.0  30141.0      0.0      crdtop_gpu = gpuarray.empty(shape=(3, npixc), dtype=real_dtype)
   277                                               # will be set on GPU
   278         2     315836.0 157918.0      0.0      matvis_gpus = [
   279                                                   gpuarray.empty(shape=(nfeed * nant, nfeed * nant), dtype=complex_dtype)
   280         1       1760.0   1760.0      0.0          for _ in range(nchunks)
   281                                               ]
   282                                           
   283                                               # output CPU buffers for downloading answers
   284         2     651687.0 325843.5      0.0      matvis_cpus = [
   285                                                   np.zeros(shape=(nfeed * nant, nfeed * nant), dtype=complex_dtype)
   286         1       1670.0   1670.0      0.0          for _ in range(nchunks)
   287                                               ]
   288         1      66214.0  66214.0      0.0      streams = [driver.Stream() for _ in range(nchunks)]
   289         1       4360.0   4360.0      0.0      event_order = [
   290                                                   "start",
   291                                                   "upload",
   292                                                   "eq2top",
   293                                                   "tau",
   294                                                   "meas_eq",
   295                                                   "vis",
   296                                                   "end",
   297                                               ]
   298                                           
   299         1        298.0    298.0      0.0      if use_uvbeam:
   300         1       2331.0   2331.0      0.0          event_order.insert(4, "interpolation")
   301                                           
   302         1 1144808032.0    1e+09      8.4      vis = np.full((ntimes, nfeed * nant, nfeed * nant), 0.0, dtype=complex_dtype)
   303                                           
   304         1    4438410.0    4e+06      0.0      logger.info(f"Running With {nchunks} chunks")
   305                                           
   306         1        819.0    819.0      0.0      report_chunk = ntimes // 100 + 1
   307         1     228634.0 228634.0      0.0      pr = psutil.Process()
   308         1       2195.0   2195.0      0.0      tstart = time.time()
   309         1      82506.0  82506.0      0.0      mlast = pr.memory_info().rss
   310         1        280.0    280.0      0.0      plast = tstart
   311                                           
   312       721    1297656.0   1799.8      0.0      for t in range(ntimes):
   313       720   86764510.0 120506.3      0.6          eq2top_gpu.set(eq2tops[t])  # defines sky orientation for this time step
   314       720   51062123.0  70919.6      0.4          events = [{e: driver.Event() for e in event_order} for _ in range(nchunks)]
   315                                           
   316      1440   19571394.0  13591.2      0.1          for c, (stream, event) in enumerate(zip(streams, events)):
   317       720    5725671.0   7952.3      0.0              event["start"].record(stream)
   318       720   68264421.0  94811.7      0.5              crd_eq_gpu.set_async(crd_eq[:, c * npixc : (c + 1) * npixc], stream=stream)
   319       720   42089947.0  58458.3      0.3              Isqrt_gpu.set_async(Isqrt[c * npixc : (c + 1) * npixc], stream=stream)
   320       720    3891194.0   5404.4      0.0              event["upload"].record(stream)
   321                                           
   322       720   28396215.0  39439.2      0.2              cublasSetStream(h, stream.handle)
   323                                           
   324                                                       # cublas arrays are in Fortran order, so P=M*N is actually
   325                                                       # peformed as P.T = N.T * M.T
   326      1440   53870427.0  37410.0      0.4              cublas_real_mm(  # compute crdtop = dot(eq2top,crd_eq)
   327       720     278594.0    386.9      0.0                  h,
   328       720     182673.0    253.7      0.0                  "n",
   329       720     152313.0    211.5      0.0                  "n",
   330       720     274632.0    381.4      0.0                  npixc,
   331       720     141267.0    196.2      0.0                  3,
   332       720     140637.0    195.3      0.0                  3,
   333       720     258961.0    359.7      0.0                  1.0,
   334       720     276288.0    383.7      0.0                  crd_eq_gpu.gpudata,
   335       720     337349.0    468.5      0.0                  npixc,
   336       720     324265.0    450.4      0.0                  eq2top_gpu.gpudata,
   337       720     232138.0    322.4      0.0                  3,
   338       720     271988.0    377.8      0.0                  0.0,
   339       720     477730.0    663.5      0.0                  crdtop_gpu.gpudata,
   340       720     151031.0    209.8      0.0                  npixc,
   341                                                       )
   342       720    3969175.0   5512.7      0.0              event["eq2top"].record(stream)
   343                                           
   344       720  123774668.0 171909.3      0.9              tx, ty, tz = crdtop_gpu.get_async(stream=stream)
   345       720   20045052.0  27840.3      0.1              above_horizon = tz > 0
   346       720   20994825.0  29159.5      0.2              tx = tx[above_horizon]
   347       720   15963740.0  22171.9      0.1              ty = ty[above_horizon]
   348       720    1475455.0   2049.2      0.0              nsrcs_up = len(tx)
   349                                           
   350       720     299321.0    415.7      0.0              if nsrcs_up < 1:
   351                                                           continue
   352                                           
   353      1440  168748033.0 117186.1      1.2              crdtop_lim_gpu = gpuarray.to_gpu_async(
   354       720  150851239.0 209515.6      1.1                  crdtop_gpu.get_async(stream=stream)[:, above_horizon].copy(),
   355       720     236185.0    328.0      0.0                  stream=stream,
   356                                                       )
   357                                           
   358       720  539108855.0 748762.3      3.9              tau_gpu = gpuarray.empty(shape=(nant, nsrcs_up), dtype=real_dtype)
   359                                           
   360      1440   73594673.0  51107.4      0.5              cublas_real_mm(  # compute tau = dot(antpos,crdtop) / speed_of_light
   361       720     202968.0    281.9      0.0                  h,
   362       720     217770.0    302.5      0.0                  "n",
   363       720     153511.0    213.2      0.0                  "n",
   364       720     158427.0    220.0      0.0                  nsrcs_up,
   365       720     187178.0    260.0      0.0                  nant,
   366       720     197736.0    274.6      0.0                  3,
   367       720     585618.0    813.4      0.0                  ONE_OVER_C,
   368       720     328408.0    456.1      0.0                  crdtop_lim_gpu.gpudata,
   369       720     166174.0    230.8      0.0                  nsrcs_up,
   370       720     493924.0    686.0      0.0                  antpos_gpu.gpudata,
   371       720     154352.0    214.4      0.0                  3,
   372       720     197774.0    274.7      0.0                  0.0,
   373       720     178494.0    247.9      0.0                  tau_gpu.gpudata,
   374       720     141874.0    197.0      0.0                  nsrcs_up,
   375                                                       )
   376       720    6054186.0   8408.6      0.0              event["tau"].record(stream)
   377                                           
   378                                                       # Need to do this in polar coordinates, NOT (l,m), at least for
   379                                                       # polarized beams. This is because at zenith, the Efield components are
   380                                                       # discontinuous (in power they are continuous). When interpolating the
   381                                                       # E-field components, you need to treat the zenith point differently
   382                                                       # depending on which "side" of zenith you're on. This is doable in polar
   383                                                       # coordinates, but not in Cartesian coordinates.
   384      1440 2838809338.0    2e+06     20.8              A_gpu = do_beam_interpolation(
   385       720     189632.0    263.4      0.0                  freq,
   386       720     244638.0    339.8      0.0                  beam_list,
   387       720     158752.0    220.5      0.0                  polarized,
   388       720     187166.0    260.0      0.0                  nthreads,
   389       720     149233.0    207.3      0.0                  nax,
   390       720     198479.0    275.7      0.0                  nfeed,
   391       720     292005.0    405.6      0.0                  complex_dtype,
   392       720     281077.0    390.4      0.0                  nbeam,
   393       720     187413.0    260.3      0.0                  use_uvbeam,
   394       720     294128.0    408.5      0.0                  daz,
   395       720     360368.0    500.5      0.0                  dza,
   396       720     202330.0    281.0      0.0                  beam_interp,
   397       720     262534.0    364.6      0.0                  beam_data_gpu,
   398       720     153403.0    213.1      0.0                  event,
   399       720     250787.0    348.3      0.0                  stream,
   400       720     303616.0    421.7      0.0                  tx,
   401       720     314067.0    436.2      0.0                  ty,
   402       720     144374.0    200.5      0.0                  nsrcs_up,
   403                                                       )
   404                                           
   405      1440  449834384.0 312385.0      3.3              v_gpu = gpuarray.empty(
   406       720    2934576.0   4075.8      0.0                  shape=(nfeed * nant, nax * nsrcs_up), dtype=complex_dtype
   407                                                       )
   408      1440  112677190.0  78248.0      0.8              Isqrt_lim_gpu = gpuarray.to_gpu_async(
   409       720  134820953.0 187251.3      1.0                  Isqrt_gpu.get()[above_horizon].copy(), stream=stream
   410                                                       )
   411                                           
   412       720    5744546.0   7978.5      0.0              _logdebug(A_gpu, "Beam")
   413                                           
   414                                                       # compute v = A * sqrtI * exp(1j*tau*freq)
   415                                                       # Ways to block up threads for sending to GPU calculations. "Meas" is for the
   416                                                       # measurement equation function, and "prod" is for the inner-product calculation.
   417       720   11699278.0  16249.0      0.1              block, grid = _get_3d_block_grid(nthreads, nsrcs_up, nant * nax, nfeed)
   418                                           
   419       720     363491.0    504.8      0.0              if t == 0:
   420         2    5845327.0    3e+06      0.0                  logger.info(
   421         1     109663.0 109663.0      0.0                      f"Using {block} = {np.prod(block)} threads in total, in a grid of {grid}, "
   422                                                               "for measurement equation."
   423                                                           )
   424                                           
   425      1440   82390816.0  57215.8      0.6              meas_eq(
   426       720     172640.0    239.8      0.0                  A_gpu,
   427       720     178986.0    248.6      0.0                  Isqrt_lim_gpu,
   428       720     181394.0    251.9      0.0                  tau_gpu,
   429       720     200914.0    279.0      0.0                  ang_freq,
   430       720    5523237.0   7671.2      0.0                  np.uint(nsrcs_up),
   431       720     343634.0    477.3      0.0                  beam_idx,
   432       720     233991.0    325.0      0.0                  v_gpu,
   433       720     154717.0    214.9      0.0                  grid=grid,
   434       720     147000.0    204.2      0.0                  block=block,
   435       720     141509.0    196.5      0.0                  stream=stream,
   436                                                       )
   437       720    5683079.0   7893.2      0.0              event["meas_eq"].record(stream)
   438                                           
   439       720    2229402.0   3096.4      0.0              _logdebug(v_gpu, "vant")
   440                                           
   441                                                       # compute vis = dot(v, v.T)
   442                                                       # We want to take an outer product over feeds/antennas, contract over
   443                                                       # E-field components, and integrate over the sky.
   444                                                       # Remember cublas is in fortran order...
   445                                                       # v_gpu is (nfeed * nant, nax * nsrcs_up)
   446      1440  235647197.0 163643.9      1.7              cublas_complex_mm(
   447       720     165555.0    229.9      0.0                  h,
   448       720     177923.0    247.1      0.0                  "c",  # conjugate transpose for first (remember fortran order)
   449       720     161621.0    224.5      0.0                  "n",  # no transpose for second.
   450       720    1154721.0   1603.8      0.0                  nfeed * nant,
   451       720    1086741.0   1509.4      0.0                  nfeed * nant,
   452       720    1050198.0   1458.6      0.0                  nax * nsrcs_up,
   453       720     207462.0    288.1      0.0                  1.0,
   454       720     242542.0    336.9      0.0                  v_gpu.gpudata,
   455       720    1111944.0   1544.4      0.0                  nax * nsrcs_up,
   456       720     225729.0    313.5      0.0                  v_gpu.gpudata,
   457       720    1138109.0   1580.7      0.0                  nax * nsrcs_up,
   458       720     177745.0    246.9      0.0                  0.0,
   459       720     554096.0    769.6      0.0                  matvis_gpus[c].gpudata,
   460       720    1040362.0   1444.9      0.0                  nfeed * nant,
   461                                                       )
   462                                           
   463       720    2645311.0   3674.0      0.0              _logdebug(matvis_gpus[c], "Vis")
   464                                           
   465       720    5274418.0   7325.6      0.0              event["vis"].record(stream)
   466                                           
   467       720 2199388868.0    3e+06     16.1              matvis_gpus[c].get(ary=matvis_cpus[c], stream=stream)
   468       720    8657100.0  12023.8      0.1              event["end"].record(stream)
   469       720    5549896.0   7708.2      0.0          events[nchunks - 1]["end"].synchronize()
   470       720 1839273445.0    3e+06     13.4          vis[t] = sum(matvis_cpus)
   471                                           
   472       720    1961787.0   2724.7      0.0          if not (t % report_chunk or t == ntimes - 1):
   473        90  857391082.0    1e+07      6.3              plast, mlast = _log_progress(tstart, plast, t + 1, ntimes, pr, mlast)
   474                                           
   475                                               # teardown GPU configuration
   476         1     561312.0 561312.0      0.0      cublasDestroy(h)
   477         1 1535551490.0    2e+09     11.2      vis = vis.conj().reshape((ntimes, nfeed, nant, nfeed, nant))
   478         1      15698.0  15698.0      0.0      return vis.transpose((0, 1, 3, 2, 4)) if polarized else vis[:, 0, :, 0, :]

